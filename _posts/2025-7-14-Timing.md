---
title: Timing and Profiling Techniques on STM32 Microcontrollers
date: 2025-07-14 06:20:52 +0000
tags: [mcu, CortexM, ARM]
---

<h3 id="introduction" style="font-weight: bold;">Introduction</h3>
Performance tuning and accurate timing measurements are critical in embedded development, especially for real-time systems and power-sensitive applications. STM32 microcontrollers, based on ARM Cortex-M cores, offer a variety of methods to profile code execution and measure timing. This blog explores practical techniques to measure execution cycles and timing on STM32, covering hardware and software approaches.

---

<h3 id="why-timing-matters" style="font-weight: bold;">Why Timing Matters</h3>
Knowing how long a block of code takes to execute—down to the clock cycle—helps you:
- Optimize algorithms for speed or energy efficiency
- Ensure real-time deadlines are met
- Debug performance bottlenecks
- Validate hardware and software integration

---

<h3 id="methods-of-measurement" style="font-weight: bold;">Methods of Measurement</h3>

Below, we discuss popular techniques for cycle counting and timing on STM32 platforms, with detailed steps and practical notes for each.

---

<h4 id="dwt-cyccnt" style="font-weight: bold;">1. Using DWT_CYCCNT (Data Watchpoint and Trace Unit)</h4>
The ARM Cortex-M3, M4, and M7 cores include a built-in cycle counter: <code>DWT-&gt;CYCCNT</code>. This register counts CPU clock cycles and is extremely precise for profiling small code sections.

**How It Works:**
- The DWT unit is part of the ARM debug system. The <code>CYCCNT</code> register increments every clock cycle.
- You can enable or reset it via software.
- Read its value before and after your code to get the cycle count.

**Code Example:**
```c
// Enable DWT cycle counter (one-time setup)
CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk; // Enable debug
DWT->CYCCNT = 0; // Reset counter
DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk; // Enable cycle counter

// Start measurement
uint32_t start = DWT->CYCCNT;

// ... code to profile ...

uint32_t end = DWT->CYCCNT;
uint32_t cycles = end - start;
```

**Practical Notes:**
- **Pros:** High precision, minimal overhead, perfect for tight loops or ISR profiling.
- **Cons:** Not available on Cortex-M0/M0+; may be disabled in low-power modes.
- **Tip:** If you run code in an RTOS context, consider possible interruptions.

---

<h4 id="hardware-timers" style="font-weight: bold;">2. Using Hardware Timers (TIMx)</h4>
All STM32 chips offer general-purpose hardware timers. By configuring a timer at a known frequency (ideally matching the CPU clock), you can measure intervals with moderate accuracy.

**How It Works:**
- Initialize a hardware timer (TIMx) in up-counting mode.
- Set its clock source to a known frequency (e.g., system clock).
- Read its value before and after your code; difference gives elapsed ticks.

**Code Example (HAL):**
```c
// Timer configuration (done once)
// HAL_TIM_Base_Init(&htimx);
// HAL_TIM_Base_Start(&htimx);

__HAL_TIM_SET_COUNTER(&htimx, 0);        // Reset counter

uint32_t start = __HAL_TIM_GET_COUNTER(&htimx);

// ... code to profile ...

uint32_t end = __HAL_TIM_GET_COUNTER(&htimx);
uint32_t ticks = end - start;
```
To convert ticks to cycles:
```
cycles = ticks * (timer_clock_freq / cpu_clock_freq)
```
Or, if timer runs at CPU frequency:
```
cycles = ticks
```

**Practical Notes:**
- **Pros:** Works on all STM32 devices, including M0/M0+.
- **Cons:** Lower resolution than DWT; timer configuration is required; possible overflow for long measurements.
- **Tip:** Use a 32-bit timer for longer code sections to avoid overflow.

---

<h4 id="manual-instruction-counting" style="font-weight: bold;">3. Manual Instruction Counting</h4>
Disassemble your code and count the instructions. Multiply by the cycle cost of each instruction (refer to ARM documentation).

**How It Works:**
- Compile your code and inspect the disassembly (e.g., via `objdump`, IDE).
- List out instructions for the code section.
- Look up cycle counts for each instruction from the ARM reference manual.
- Sum them for total cycle count.

**Example:**
Suppose your code compiles to:
```
MOV R0, #1    ; 1 cycle
ADD R1, R0, #2; 1 cycle
STR R1, [R2]  ; 2 cycles (memory access)
```
Total: **4 cycles**

**Practical Notes:**
- **Pros:** Useful for extremely simple routines or hand-optimized assembly.
- **Cons:** Tedious and impractical for complex code, branches, loops, or with interrupts.
- **Tip:** Use for educational purposes or micro-optimization only.

---

<h4 id="ide-profilers" style="font-weight: bold;">4. IDE Profilers and Debuggers</h4>
Modern IDEs (STM32CubeIDE, Keil MDK, IAR Embedded Workbench) offer cycle-accurate profiling when connected via SWD/JTAG. These tools typically use the DWT unit or hardware breakpoints.

**How It Works:**
- Connect your hardware debugger (ST-Link, J-Link, etc.).
- Open your IDE's profiling or performance analysis tool.
- Set breakpoints at the start/end of your code block.
- Run code and capture profiling statistics (cycles, time, call graphs, etc.).

**Example Steps (STM32CubeIDE):**
1. Build and flash your project.
2. Open the "Performance Analyzer" or "Instruction Profiling" tool.
3. Mark regions to profile, run the code.
4. View detailed statistics in the IDE.

**Practical Notes:**
- **Pros:** Visual, detailed, supports call graphs and code coverage.
- **Cons:** Requires debugger hardware and IDE; may slow execution slightly.
- **Tip:** Use for whole-project analysis, not just microbenchmarking.

---

<h4 id="time-to-cycles" style="font-weight: bold;">5. Measuring Time and Converting to Cycles</h4>
If you can measure elapsed time (using SysTick, timers, etc.), you can convert it to cycles.

**How It Works:**
- Measure the elapsed time for your code (microseconds, milliseconds).
- Multiply by the MCU frequency to get cycles.

**Example Calculation:**
If you measure 50 microseconds on a 72 MHz CPU:
```
cycles = 50e-6 * 72e6 = 3600 cycles
```

**Practical Notes:**
- **Pros:** Straightforward if you already use time-based measurements.
- **Cons:** Accuracy depends on timer resolution and the precision of your time measurement.
- **Tip:** Use for profiling longer code sections or when cycle counting is unavailable.

---

<h4 id="rtos-trace" style="font-weight: bold;">6. RTOS Trace Tools</h4>
If you use an RTOS (e.g., FreeRTOS), some trace tools can profile task or function execution time, sometimes in cycles.

**How It Works:**
- Enable trace hooks in your RTOS (often done in configuration).
- Use a trace tool (e.g., FreeRTOS+Trace, Percepio Tracealyzer).
- Run your application; the tool collects timing information for tasks, ISRs, and functions.

**Example:**
- FreeRTOS+Trace can show task execution time, CPU usage, and sometimes cycles (if DWT or timers are used).

**Practical Notes:**
- **Pros:** Great for system-level profiling and optimization.
- **Cons:** Requires RTOS support and extra software; may add runtime overhead.
- **Tip:** Ideal for profiling multitasking behavior and system bottlenecks.

---

<h3 id="summary" style="font-weight: bold;">Summary Table</h3>

| Method                  | Accuracy   | Hardware Needed     | Notes                                |
|-------------------------|------------|---------------------|--------------------------------------|
| DWT_CYCCNT              | High       | Cortex-M3/M4/M7     | Most precise; not on M0/M0+          |
| TIMx Timer              | Medium     | Any STM32           | Needs timer configuration            |
| Manual Instruction Count| Low        | None                | Tedious; variable cycle counts       |
| IDE Profiler            | High       | Debugger + IDE      | Visual; needs debug connection       |
| Time Measurement        | Medium     | Any STM32           | Needs precise timer/frequency info   |
| RTOS Trace Tools        | Medium/High| RTOS + Trace support| Depends on RTOS/tool                 |

---

<h3 id="best-practices" style="font-weight: bold;">Best Practices</h3>
- **Prefer DWT_CYCCNT** for quick and accurate measurement if available.
- **Use hardware timers** as a fallback on simpler cores.
- **Leverage IDE tools** for deep profiling or when visual feedback is required.
---

<h3 id="conclusion" style="font-weight: bold;">Conclusion</h3>
Accurate timing and profiling are essential for robust embedded development on STM32 microcontrollers. Whether you use built-in cycle counters, hardware timers, or advanced IDE tools, understanding these techniques enables you to write faster, more reliable firmware—and deliver on real-time promises.

---
